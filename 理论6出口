import { connect } from 'cloudflare:sockets'

// å…­åœ°åŒºæ˜ å°„å¯¹åº”CF CDN IP
const cfIpTable = {
  kr: '104.16.156.117',
  de: '104.16.156.249',
  sg: '104.16.158.80',
  us: '104.16.158.127',
  jp: '104.16.158.191',
  hk: '104.16.158.91'
};

// å…­ä¸ªåä»£åŸŸåï¼ˆç”¨äºå‡ºå£åˆ†æµï¼Œå®é™…ä½œä¸ºåç«¯è½¬å‘ç›®æ ‡ï¼Œä¸å½±å“èŠ‚ç‚¹æ¨¡æ¿è¾“å‡ºï¼‰
const relayHosts = {
  kr: 'ProxyIP.KR.CMLiussss.net',
  de: 'ProxyIP.DE.tp2024.CMLiussss.net',
  sg: 'ProxyIP.SG.CMLiussss.net',
  us: 'ProxyIP.US.CMLiussss.net',
  jp: 'ProxyIP.JP.CMLiussss.net',
  hk: 'ProxyIP.HK.CMLiussss.net'
};

let tunnelKey = '6f55f6c1-3575-45fa-9bdf-2b5654185f4a'; // å»ºè®®ç”¨ä½ çš„UUIDæ”¹æ‰

function é›¨åæ¸…é£(tk) {
  const reg = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return reg.test(tk);
}
if (!é›¨åæ¸…é£(tunnelKey)) throw new Error('tunnelKeyéæ³•');

export default {
  async fetch(æ™¨éœœåˆç…§, èŠ¸çª—ç´ä¹¦, æ³¢å…‰ä¸‡é¡·) {
    tunnelKey = èŠ¸çª—ç´ä¹¦.TUNNEL_KEY || tunnelKey;
    const url = new URL(æ™¨éœœåˆç…§.url);
    const region = url.searchParams.get('region')?.toLowerCase() || '';
    let relayHost = relayHosts[region] || relayHosts.us;
    const host = æ™¨éœœåˆç…§.headers.get('Host');
    const é£å…¥æ¾ = æ™¨éœœåˆç…§.headers.get('Upgrade');
    if (!é£å…¥æ¾ || é£å…¥æ¾ !== 'websocket') {
      switch (url.pathname) {
        case '/':
          return new Response('é£èµ·äº‘æ¶Œ åªåœ¨æ­¤ Worker äº‘ä¸­ã€‚', { status: 200 });
        case '/app': {
          return new Response(æ³‰çŸ³æ¸…éŸ³(tunnelKey, host), {
            status: 200,
            headers: { "Content-Type": "text/plain;charset=utf-8" }
          });
        }
        default:
          return new Response('è¯—å°½äº‘å½’', { status: 404 });
      }
    } else {
      return await æœˆæ˜ å¯’æ±Ÿ(æ™¨éœœåˆç…§, relayHost);
    }
  },
}

// /appè¾“å‡º6ä¸ªCF CDN IPèŠ‚ç‚¹ï¼Œhostä¿æŒå½“å‰WorkeråŸŸåï¼Œåˆ†æµå‚æ•°æ˜ å°„
function æ³‰çŸ³æ¸…éŸ³(key, host) {
  const proto = 'vless';
  const isWorkers = /\.workers\.dev$/.test(host);
  const port = isWorkers ? 80 : 443;
  const wsPathBase = '/?ed=2048&region=';
  const security = !isWorkers ? '&security=tls' : '';
  const tls = !isWorkers ? 'true' : 'false';

  let txt = '======= å¤šåœ°åŒºCF CDNå‡ºå£èŠ‚ç‚¹ï¼ˆå…¨é€‰å¤åˆ¶ï¼‰ =======\n';
  txt += `Host: ${host}\nPort: ${port}\nTLS: ${tls}\n\n`;
  const nodeOrder = ['kr','de','sg','us','jp','hk'];
  for (const code of nodeOrder) {
    txt += `${regionFlagEmoji(code)} ${code.toUpperCase()} (${cfIpTable[code]})\n`
      + `${proto}://${key}@${cfIpTable[code]}:${port}?encryption=none&type=ws&host=${host}&path=${wsPathBase}${code}${security}\n\n`;
  }
  txt += `UUID: ${key}\naddressä¸ºCF CDN IPï¼Œhostä¸ºå½“å‰WorkeråŸŸåï¼ŒWebSocketè·¯å¾„å‚æ•°åŒºåˆ†åœ°åŒº\nå…¨éƒ¨é€‰ä¸­å¤åˆ¶è¿›V2RayN/V2Box/Shadowrocket\n======= END =======\n`;
  return txt;
}
function regionFlagEmoji(code) {
  const flags = { kr:'ğŸ‡°ğŸ‡·', de:'ğŸ‡©ğŸ‡ª', us:'ğŸ‡ºğŸ‡¸', sg:'ğŸ‡¸ğŸ‡¬', jp:'ğŸ‡¯ğŸ‡µ', hk:'ğŸ‡­ğŸ‡°' };
  return flags[code] || '';
}

// åç«¯å‡ºå£é€»è¾‘/åˆ†æµå‡ä¸å˜
async function æœˆæ˜ å¯’æ±Ÿ(æ™´å·å†å†, relayHost) {
  const pair = new WebSocketPair();
  const [ç²¼ç²¼æ°´é¢, æ½‡æ½‡é›¨æ­‡] = Object.values(pair);
  æ½‡æ½‡é›¨æ­‡.accept();
  let æ±Ÿå—çƒŸæ°´ = '';
  let èŠ¦è‹‡éšé£ = '';
  const log = (è¯—å¥, ç«¹æ—) => console.log(`[${æ±Ÿå—çƒŸæ°´}:${èŠ¦è‹‡éšé£}] ${è¯—å¥}`, ç«¹æ— || '');
  const äº‘èµ·æ—¶ = æ™´å·å†å†.headers.get('sec-websocket-protocol') || '';
  const è¯—æµ = æ°´å¢¨æµè§(æ½‡æ½‡é›¨æ­‡, äº‘èµ·æ—¶, log);
  let ä¸´æ°´é«˜æ¥¼ = { value: null };
  let udpStreamWrite = null;
  let isDns = false;
  è¯—æµ.pipeTo(new WritableStream({
    async write(éœ“è£³ç¾½è¡£, controller) {
      if (isDns && udpStreamWrite) return udpStreamWrite(éœ“è£³ç¾½è¡£)
      if (ä¸´æ°´é«˜æ¥¼.value) {
        const writer = ä¸´æ°´é«˜æ¥¼.value.writable.getWriter();
        await writer.write(éœ“è£³ç¾½è¡£);
        writer.releaseLock();
        return
      }
      const r = èŠ±é—´ä¸€å£¶é…’(éœ“è£³ç¾½è¡£, tunnelKey)
      const { hasError, message, portRemote=443, addressRemote='', rawDataIndex, tunnelVersion=new Uint8Array([0,0]), isUDP } = r;
      æ±Ÿå—çƒŸæ°´ = addressRemote; èŠ¦è‹‡éšé£ = `${portRemote}--${Math.random()} ${isUDP?'udp ':'tcp '}`
      if (hasError) throw new Error(message)
      if (isUDP) {
        if (portRemote === 53) isDns = true
        else throw new Error('UDPä»…æ”¯æŒDNS')
      }
      const tunnelResponseHeader = new Uint8Array([tunnelVersion[0],0]);
      const rawClientData = éœ“è£³ç¾½è¡£.slice(rawDataIndex);
      if (isDns) {
        const { write } = await å±±å·ä¹…è¿œ(æ½‡æ½‡é›¨æ­‡, tunnelResponseHeader, log);
        udpStreamWrite = write
        udpStreamWrite(rawClientData)
        return
      }
      æ±Ÿæ¹–å¤œé›¨(ä¸´æ°´é«˜æ¥¼, addressRemote, portRemote, rawClientData, æ½‡æ½‡é›¨æ­‡, tunnelResponseHeader, log, relayHost)
    },
    close() { log('è¯—æµç»ˆé—­') },
    abort(reason) { log('è¯—æµç»ˆæ­¢', JSON.stringify(reason)) },
  })).catch(err => {
    log('è¯—æµpipeToå‡ºé”™', err)
  })
  return new Response(null, { status:101, webSocket:ç²¼ç²¼æ°´é¢ })
}

function æ°´å¢¨æµè§(webSocketServer, earlyDataHeader, log) {
  let readableStreamCancel = false
  const stream = new ReadableStream({
    start(controller) {
      webSocketServer.addEventListener('message', (event) => {
        if (readableStreamCancel) return
        controller.enqueue(event.data)
      })
      webSocketServer.addEventListener('close', () => {
        safeCloseWebSocket(webSocketServer)
        if (readableStreamCancel) return
        controller.close()
      })
      webSocketServer.addEventListener('error', (err) => {
        log('webSocketServer has error'); controller.error(err)
      })
      const { earlyData, error } = å¤©å…‰äº‘å½±(earlyDataHeader)
      if (error) controller.error(error)
      else if (earlyData) controller.enqueue(earlyData)
    },
    cancel(reason) {
      if (readableStreamCancel) return
      log(`ReadableStream was canceled, due to ${reason}`)
      readableStreamCancel = true
      safeCloseWebSocket(webSocketServer)
    }
  })
  return stream
}

function èŠ±é—´ä¸€å£¶é…’(buffer, tk) {
  if (buffer.byteLength < 24) return {hasError:true, message:'invalid data'}
  const version = new Uint8Array(buffer.slice(0, 1))
  let ok = false
  if (ç„ç‰é›•å¼“(new Uint8Array(buffer.slice(1, 17))) === tk) ok = true
  if (!ok) return {hasError:true, message:'éæ³•å£ä»¤'}
  const optLength = new Uint8Array(buffer.slice(17,18))[0]
  const command = new Uint8Array(buffer.slice(18+optLength, 18+optLength+1))[0]
  let isUDP = (command === 2)
  const portIndex = 18 + optLength + 1
  const portRemote = new DataView(buffer.slice(portIndex, portIndex+2)).getUint16(0)
  let addressIndex = portIndex+2
  const addressType = new Uint8Array(buffer.slice(addressIndex, addressIndex+1))[0]
  let addressValueIndex = addressIndex + 1
  let addressValue = ''
  switch (addressType) {
    case 1: addressValue = new Uint8Array(buffer.slice(addressValueIndex,addressValueIndex+4)).join('.'); break
    case 2:
      const n = new Uint8Array(buffer.slice(addressValueIndex, addressValueIndex+1))[0]
      addressValueIndex += 1
      addressValue = new TextDecoder().decode(buffer.slice(addressValueIndex, addressValueIndex+n))
      break
    case 3:
      const dv = new DataView(buffer.slice(addressValueIndex, addressValueIndex+16))
      const ipv6 = []
      for(let i=0; i<8; i++) ipv6.push(dv.getUint16(i*2).toString(16))
      addressValue = ipv6.join(':')
      break
    default: return {hasError:true, message:'æœªçŸ¥åœ°å€ç±»å‹'}
  }
  return {
    hasError:false, addressRemote:addressValue, addressType,
    portRemote, rawDataIndex: addressValueIndex + (
      addressType==2 ? (new Uint8Array(buffer.slice(addressValueIndex-1,addressValueIndex))[0])
      : (addressType==1?4:16)
    ),
    tunnelVersion: version, isUDP
  }
}

async function æ±Ÿæ¹–å¤œé›¨(remoteSocket, addressRemote, portRemote, rawClientData, webSocket, tunnelResponseHeader, log, relayHost) {
  async function connectAndWrite(address, port) {
    const tcpSocket = connect({hostname: address, port});
    remoteSocket.value = tcpSocket
    log(`connected to ${address}:${port}`)
    const writer = tcpSocket.writable.getWriter()
    await writer.write(rawClientData)
    writer.releaseLock()
    return tcpSocket
  }
  async function retry() {
    const tcpSocket = await connectAndWrite(relayHost || addressRemote, portRemote)
    tcpSocket.closed.catch(error => {console.log('retry tcpSocket closed error', error)})
      .finally(()=>{safeCloseWebSocket(webSocket)})
    åƒé‡Œæ±Ÿé™µ(tcpSocket, webSocket, tunnelResponseHeader, null, log)
  }
  if (addressRemote === "2602:fc59:b0:64::") {
    // NAT64å…¥å£ï¼Œå¼ºåˆ¶ relayHost å‡ºå£
    const tcpSocket = await connectAndWrite(relayHost, portRemote)
    åƒé‡Œæ±Ÿé™µ(tcpSocket, webSocket, tunnelResponseHeader, null, log)
    return
  }
  // ä¼˜å…ˆç›´è¿ï¼Œå† fallback ç”¨ relayHost
  const tcpSocket = await connectAndWrite(addressRemote, portRemote)
  åƒé‡Œæ±Ÿé™µ(tcpSocket, webSocket, tunnelResponseHeader, retry, log)
}

async function åƒé‡Œæ±Ÿé™µ(remoteSocket, webSocket, tunnelResponseHeader, retry, log) {
  let vlessHeader=tunnelResponseHeader
  let hasIncomingData=false
  await remoteSocket.readable.pipeTo(new WritableStream({
    async write(chunk, controller) {
      hasIncomingData = true
      if(webSocket.readyState !== 1) controller.error('webSocketæœªå¼€å¯,å¯èƒ½å…³é—­')
      if(vlessHeader) {
        webSocket.send(await new Blob([vlessHeader, chunk]).arrayBuffer())
        vlessHeader = null
      } else {
        webSocket.send(chunk)
      }
    },
    close() { log('socket.readableå…³é—­', hasIncomingData) },
    abort(reason) { console.error('socket.readableå¼‚å¸¸', reason) }
  })).catch((error)=>{
    console.error("åƒé‡Œæ±Ÿé™µå¼‚å¸¸", error.stack || error)
    safeCloseWebSocket(webSocket)
  })
  if(hasIncomingData===false && retry) {
    log('å°è¯•é‡è¯•')
    retry()
  }
}

function å¤©å…‰äº‘å½±(base64Str) {
  if (!base64Str) return { error:null }
  try {
    base64Str = base64Str.replace(/-/g,'+').replace(/_/g,'/')
    const decode = atob(base64Str)
    const arryBuffer = Uint8Array.from(decode, c => c.charCodeAt(0))
    return {earlyData: arryBuffer.buffer, error:null}
  } catch(error) {
    return { error }
  }
}

async function å±±å·ä¹…è¿œ(webSocket, tunnelResponseHeader, log) {
  let isTunnelHeaderSent=false
  const transformStream = new TransformStream({
    transform(chunk, controller){
      for(let i=0; i<chunk.byteLength; ) {
        const lengthBuffer = chunk.slice(i,i+2)
        const udpLength = new DataView(lengthBuffer).getUint16(0)
        const udpData = new Uint8Array(chunk.slice(i+2, i+2+udpLength))
        controller.enqueue(udpData)
        i+=2+udpLength
      }
    }
  })
  transformStream.readable.pipeTo(new WritableStream({
    async write(chunk) {
      const resp = await fetch("https://1.1.1.1/dns-query", {
        method:'POST', headers:{'content-type':'application/dns-message'}, body:chunk
      })
      const dnsQuery = await resp.arrayBuffer()
      const udpSize = dnsQuery.byteLength
      const udpSizeBuffer = new Uint8Array([(udpSize>>8)&0xff, udpSize&0xff])
      if (webSocket.readyState===1) {
        log(`DOHæˆåŠŸ,dnsé•¿åº¦:${udpSize}`)
        if(isTunnelHeaderSent){
          webSocket.send(await new Blob([udpSizeBuffer, dnsQuery]).arrayBuffer())
        }else{
          webSocket.send(await new Blob([tunnelResponseHeader, udpSizeBuffer, dnsQuery]).arrayBuffer())
          isTunnelHeaderSent = true
        }
      }
    }
  })).catch(error=>log('dns udpå¼‚å¸¸'+error))
  const writer = transformStream.writable.getWriter()
  return { write(chunk) { writer.write(chunk) } }
}

// uuidå·¥å…·
const byteToHex=[]
for(let i=0;i<256;++i) byteToHex.push((i+256).toString(16).slice(1))
function ç„ç‰é›•å¼“(arr, offset=0){
  return (byteToHex[arr[offset+0]]+byteToHex[arr[offset+1]]+byteToHex[arr[offset+2]]+byteToHex[arr[offset+3]]+ "-" +byteToHex[arr[offset+4]]+byteToHex[arr[offset+5]]+ "-" +byteToHex[arr[offset+6]]+byteToHex[arr[offset+7]]+ "-" +byteToHex[arr[offset+8]]+byteToHex[arr[offset+9]]+ "-" +byteToHex[arr[offset+10]]+byteToHex[arr[offset+11]]+byteToHex[arr[offset+12]]+byteToHex[arr[offset+13]]+byteToHex[arr[offset+14]]+byteToHex[arr[offset+15]]).toLowerCase()
}
function stringify(arr, offset=0) {
  const uuid = ç„ç‰é›•å¼“(arr, offset)
  if (!é›¨åæ¸…é£(uuid)) throw TypeError("Stringified tunnelKeyéæ³•")
  return uuid
}
function safeCloseWebSocket(socket) {
  try {
    if (socket.readyState === 1 || socket.readyState === 2) socket.close()
  } catch (error) { console.error('safeCloseWebSocket error', error) }
}

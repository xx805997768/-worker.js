import{connect}from"cloudflare:sockets";let userID="f7804bbb-0133-4bef-99e2-fa339b748765";let proxyIP="de.radically.pro";if(!isValidUUID(userID)){throw new Error("uuid is not valid")}export default{async fetch(e,t,r){try{userID=t.UUID||userID;proxyIP=t.PROXYIP||proxyIP;const r=e.headers.get("Upgrade");if(!r||r!=="websocket"){const t=new URL(e.url);switch(t.pathname){case"/":return new Response(JSON.stringify(e.cf),{status:200});case`/${userID}`:{const t=getVLESSConfig(userID,e.headers.get("Host"));return new Response(`${t}`,{status:200,headers:{"Content-Type":"text/plain;charset=utf-8"}})}default:return new Response("Not found",{status:404})}}else{return await vlessOverWSHandler(e)}}catch(e){let t=e;return new Response(t.toString())}}};async function vlessOverWSHandler(e){const t=new WebSocketPair;const[r,n]=Object.values(t);n.accept();let s="";let a="";const o=(e,t)=>{console.log(`[${s}:${a}] ${e}`,t||"")};const c=e.headers.get("sec-websocket-protocol")||"";const i=makeReadableWebSocketStream(n,c,o);let l={value:null};let u=null;let f=false;i.pipeTo(new WritableStream({async write(e,t){if(f&&u){return u(e)}if(l.value){const t=l.value.writable.getWriter();await t.write(e);t.releaseLock();return}const{hasError:r,message:c,portRemote:i=443,addressRemote:d="",rawDataIndex:y,vlessVersion:w=new Uint8Array([0,0]),isUDP:b}=processVlessHeader(e,userID);s=d;a=`${i}--${Math.random()} ${b?"udp ":"tcp "} `;if(r){throw new Error(c);return}if(b){if(i===53){f=true}else{throw new Error("UDP proxy only enable for DNS which is port 53");return}}const S=new Uint8Array([w[0],0]);const p=e.slice(y);if(f){const{write:e}=await handleUDPOutBound(n,S,o);u=e;u(p);return}handleTCPOutBound(l,d,i,p,n,S,o)},close(){o(`readableWebSocketStream is close`)},abort(e){o(`readableWebSocketStream is abort`,JSON.stringify(e))}})).catch((e=>{o("readableWebSocketStream pipeTo error",e)}));return new Response(null,{status:101,webSocket:r})}async function handleTCPOutBound(e,t,r,n,s,a,o){async function c(t,r){const s=connect({hostname:t,port:r});e.value=s;o(`connected to ${t}:${r}`);const a=s.writable.getWriter();await a.write(n);a.releaseLock();return s}async function i(){const e=await c(proxyIP||t,r);e.closed.catch((e=>{console.log("retry tcpSocket closed error",e)})).finally((()=>{safeCloseWebSocket(s)}));remoteSocketToWS(e,s,a,null,o)}const l=await c(t,r);remoteSocketToWS(l,s,a,i,o)}function makeReadableWebSocketStream(e,t,r){let n=false;const s=new ReadableStream({start(s){e.addEventListener("message",(e=>{if(n){return}const t=e.data;s.enqueue(t)}));e.addEventListener("close",(()=>{safeCloseWebSocket(e);if(n){return}s.close()}));e.addEventListener("error",(e=>{r("webSocketServer has error");s.error(e)}));const{earlyData:a,error:o}=base64ToArrayBuffer(t);if(o){s.error(o)}else if(a){s.enqueue(a)}},pull(e){},cancel(t){if(n){return}r(`ReadableStream was canceled, due to ${t}`);n=true;safeCloseWebSocket(e)}});return s}function processVlessHeader(e,t){if(e.byteLength<24){return{hasError:true,message:"invalid data"}}const r=new Uint8Array(e.slice(0,1));let n=false;let s=false;if(stringify(new Uint8Array(e.slice(1,17)))===t){n=true}if(!n){return{hasError:true,message:"invalid user"}}const a=new Uint8Array(e.slice(17,18))[0];const o=new Uint8Array(e.slice(18+a,18+a+1))[0];if(o===1){}else if(o===2){s=true}else{return{hasError:true,message:`command ${o} is not support, command 01-tcp,02-udp,03-mux`}}const c=18+a+1;const i=e.slice(c,c+2);const l=new DataView(i).getUint16(0);let u=c+2;const f=new Uint8Array(e.slice(u,u+1));const d=f[0];let y=0;let w=u+1;let b="";switch(d){case 1:y=4;b=new Uint8Array(e.slice(w,w+y)).join(".");break;case 2:y=new Uint8Array(e.slice(w,w+1))[0];w+=1;b=(new TextDecoder).decode(e.slice(w,w+y));break;case 3:y=16;const t=new DataView(e.slice(w,w+y));const r=[];for(let e=0;e<8;e++){r.push(t.getUint16(e*2).toString(16))}b=r.join(":");break;default:return{hasError:true,message:`invild  addressType is ${d}`}}if(!b){return{hasError:true,message:`addressValue is empty, addressType is ${d}`}}return{hasError:false,addressRemote:b,addressType:d,portRemote:l,rawDataIndex:w+y,vlessVersion:r,isUDP:s}}async function remoteSocketToWS(e,t,r,n,s){let a=0;let o=[];let c=r;let i=false;await e.readable.pipeTo(new WritableStream({start(){},async write(e,r){i=true;if(t.readyState!==WS_READY_STATE_OPEN){r.error("webSocket.readyState is not open, maybe close")}if(c){t.send(await new Blob([c,e]).arrayBuffer());c=null}else{t.send(e)}},close(){s(`remoteConnection!.readable is close with hasIncomingData is ${i}`)},abort(e){console.error(`remoteConnection!.readable abort`,e)}})).catch((e=>{console.error(`remoteSocketToWS has exception `,e.stack||e);safeCloseWebSocket(t)}));if(i===false&&n){s(`retry`);n()}}function base64ToArrayBuffer(e){if(!e){return{error:null}}try{e=e.replace(/-/g,"+").replace(/_/g,"/");const t=atob(e);const r=Uint8Array.from(t,(e=>e.charCodeAt(0)));return{earlyData:r.buffer,error:null}}catch(e){return{error:e}}}function isValidUUID(e){const t=/^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;return t.test(e)}const WS_READY_STATE_OPEN=1;const WS_READY_STATE_CLOSING=2;function safeCloseWebSocket(e){try{if(e.readyState===WS_READY_STATE_OPEN||e.readyState===WS_READY_STATE_CLOSING){e.close()}}catch(e){console.error("safeCloseWebSocket error",e)}}const byteToHex=[];for(let e=0;e<256;++e){byteToHex.push((e+256).toString(16).slice(1))}function unsafeStringify(e,t=0){return(byteToHex[e[t+0]]+byteToHex[e[t+1]]+byteToHex[e[t+2]]+byteToHex[e[t+3]]+"-"+byteToHex[e[t+4]]+byteToHex[e[t+5]]+"-"+byteToHex[e[t+6]]+byteToHex[e[t+7]]+"-"+byteToHex[e[t+8]]+byteToHex[e[t+9]]+"-"+byteToHex[e[t+10]]+byteToHex[e[t+11]]+byteToHex[e[t+12]]+byteToHex[e[t+13]]+byteToHex[e[t+14]]+byteToHex[e[t+15]]).toLowerCase()}function stringify(e，t=0){const r=unsafeStringify(e,t);if(!isValidUUID(r)){throw TypeError("Stringified UUID is invalid")}return r}async function handleUDPOutBound(e，t，r){let n=false;const s=new TransformStream({start(e){}，transform(e，t){for(let r=0;r<e.byteLength;){const n=e.slice(r,r+2);const s=new DataView(n).getUint16(0);const a=new Uint8Array(e.slice(r+2,r+2+s));r=r+2+s;t.enqueue(a)}}，flush(e){}});s.readable。pipeTo(new WritableStream({async write(s){const a=await fetch("https://1.1.1.1/dns-query"，{method:"POST",headers:{"content-type":"application/dns-message"},body:s});const o=await a.arrayBuffer();const c=o.byteLength;const i=new Uint8Array([c>>8&255,c&255]);if(e.readyState===WS_READY_STATE_OPEN){r(`doh success and dns message length is ${c}`);if(n){e.send(await new Blob([i,o])。arrayBuffer())}else{e.send(await new Blob([t,i,o])。arrayBuffer());n=true}}}}))。catch((e=>{r("dns udp has error"+e)}));const a=s.writable。getWriter();return{write(e){a.write(e)}}}function getVLESSConfig(e，t){const r=`vless://${e}@${t}:443?encryption=none&security=tls&sni=${t}&fp=randomized&type=ws&host=${t}&path=%2F%3Fed%3D2048#${t}`;return`\n################################################################\nv2ray\n---------------------------------------------------------------\n${r}\n---------------------------------------------------------------\n################################################################\nclash-meta\n---------------------------------------------------------------\n- type: vless\n  name: ${t}\n  server: ${t}\n  port: 443\n  uuid: ${e}\n  network: ws\n  tls: true\n  udp: false\n  sni: ${t}\n  client-fingerprint: chrome\n  ws-opts:\n    path: "/?ed=2048"\n    headers:\n      host: ${t}\n---------------------------------------------------------------\n################################################################\n`}
